<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>深入浅出理解接口回调 | ijaysdevbg</title><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入浅出理解接口回调</h1><a id="logo" href="/.">ijaysdevbg</a><p class="description">Salvation lies within</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">深入浅出理解接口回调</h1><div class="post-meta">2015-05-23<span class="categories"> | 分类于<a href="/categories/技术/"> 技术</a></span></div><div class="post-content"><h2 id="1-什么是接口回调？"><a href="#1-什么是接口回调？" class="headerlink" title="1.什么是接口回调？"></a>1.什么是接口回调？</h2><blockquote>
<p>接口回调是指：可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口的方法。实际上，当接口变量调用被实际实现的接口中的方法时，就是通知相信的对象调用接口的方法，这一过程成为对象功能的接口回调。</p>
</blockquote>
<p>把上面的话翻译过来可以这样理解：</p>
<ul>
<li>Class A实现接口CallBack callback  —–背景一</li>
<li>Class A中包含一个Class B的应用b    —–背景二</li>
<li>Class B中有一个参数为callback的方法f(CallBack callback)—背景三</li>
<li>A的对象a调用B的方法f(CallBack callback)—–A类调用B类的某个方法C</li>
<li>然后b就可以在f(CallBack callback)方法中调用A的方法—–B类调用A方法D</li>
</ul>
<h2 id="2-实际例子"><a href="#2-实际例子" class="headerlink" title="2.实际例子"></a>2.实际例子</h2><p>上面的描述还是稍显空洞，用一个实际例子来解释一下。有一天小王打电话问小李一个问题，小李一下子也不知道，就告诉小王说等我忙完手上的事情就去想想答案。小王在小李的过程中就出去逛街玩儿去了。过了一段时间，小李打了小王的电话，告诉他了答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> //&#36825;&#26159;&#19968;&#20010;&#22238;&#35843;&#25509;&#21475;    &#10; public interface CallbackListener &#123;&#10;void solve(String result);&#10; &#125;</span><br></pre></td></tr></table></figure>
<p>小王</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   //&#23567;&#29579;&#23454;&#29616;&#20102;&#25509;&#21475;&#65292;&#30456;&#24403;&#20110;A&#10;   public class Wang implements CallbackListener &#123;  &#10;private Li li;&#10;&#10;   //&#25345;&#26377;B&#31867;&#23567;&#26446;&#30340;&#24341;&#29992;&#10;public Wang(Li li) &#123;&#10;&#9;this.li = li;&#10;&#125;&#10;   &#10;   //&#23567;&#29579;&#36890;&#36807;&#27492;&#26041;&#27861;&#21521;&#23567;&#26446;&#38382;&#38382;&#39064;&#10;public void askQuestion(final String question) &#123;&#10;&#9;new Thread(new Runnable() &#123;&#10;&#9;&#9;public void run() &#123;&#10;                //&#35843;&#29992;&#23567;&#26446;&#30340;executeMessage&#26041;&#27861;&#10;                //&#30456;&#24403;&#20110;A&#31867;&#35843;&#29992;B&#31867;&#30340;&#26041;&#27861;C&#10;&#9;&#9;&#9;li.executeMessage(Wang.this, question);&#10;&#9;&#9;&#125;&#10;&#9;&#125;).start();&#10;    //&#38382;&#23436;&#38382;&#39064;&#20570;&#33258;&#24049;&#30340;&#20107;&#24773;&#10;&#9;play();&#10;&#125;&#10;&#10;public void play() &#123;&#10;&#9;System.out.println(&#34;&#25105;&#35201;&#21435;&#36891;&#34903;&#20102;&#34;);&#10;&#125;&#10; &#10;     //&#23567;&#26446;&#30693;&#36947;&#31572;&#26696;&#21518;&#35843;&#29992;A&#31867;&#30340;&#26041;&#27861;&#65292;&#21363;&#22238;&#35843;&#26041;&#27861;&#10;public void solve(String result) &#123;&#10;&#9;System.out.println(&#34;&#23567;&#26446;&#21578;&#35785;&#23567;&#29579;&#30340;&#31572;&#26696;&#26159;---&#62;&#34; + result);&#10;   &#125;&#10;&#10;   &#125;</span><br></pre></td></tr></table></figure>
<p>小李</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   public class Li &#123;&#10;&#10;public void executeMessage(CallbackListener callbackListener,String question)&#123;&#10;&#9;System.out.println(&#34;&#23567;&#29579;&#30340;&#21839;&#38988;&#26159;--&#62;&#34;+question);&#10;        /*&#10;         *&#27169;&#25311;&#23567;&#26446;&#38656;&#35201;&#24456;&#38271;&#26102;&#38388;&#10;         */&#10;&#9;for(int i=0;i&#60;1000;i++)&#123;&#10;&#9;&#9;&#10;&#9;&#125;&#10;&#9;String result=&#34;2&#34;;&#10;        //&#25171;&#30005;&#35805;&#21578;&#35785;&#23567;&#29579;&#65292;&#21363;&#22238;&#35843;&#26041;&#27861;&#10;&#9;callbackListener.solve(result);&#10;   &#9;&#125;&#10;   &#125;</span><br></pre></td></tr></table></figure>
<p> 测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  public class Test &#123;&#10;public static void main(String[] args) &#123;&#10;Li li = new Li();&#10;Wang wang=new Wang(li);&#10;&#10;wang.askQuestion(&#34;1+1=?&#34;);&#10; &#125;&#10;&#10;  &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是就是一个异步接口回调的例子。接下来看一个同步回调的例子。当我们为Button设置监听事件的的时候就用到了接口回调。<br>OnClickListener：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10; public interface OnClickListener &#123;&#10;    /**&#10;     * Called when a view has been clicked.&#10;     *&#10;     * @param v The view that was clicked.&#10;     */&#10;    void onClick(View v);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>MainActivity中实现了接口OnClickListener且包含了B类的引用（Button是View的子类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;   public class MainActivity extends BaseActivity implements OnClickListener &#123;&#10;&#10;   Button bt_click;&#10;&#10;@Override&#10;public void onClick(View v) &#123;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>B类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class View implements Drawable.Callback, KeyEvent.Callback,&#10;    AccessibilityEventSource &#123;&#10;...&#10;  /**&#10; * Register a callback to be invoked when this view is clicked. If this view is not&#10; * clickable, it becomes clickable.&#10; *&#10; * @param l The callback that will run&#10; *&#10; * @see #setClickable(boolean)&#10; */&#10;public void setOnClickListener(OnClickListener l) &#123;&#10;    if (!isClickable()) &#123;&#10;        setClickable(true);&#10;    &#125;&#10;    getListenerInfo().mOnClickListener = l;&#10;&#125;   &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当需要执行一些耗时操作时，A类让B类去执行，结束后再返回给A，这就是接口回调使用的情景。</p>
<p>以上就是对接口回调的一点理解。</p>
</div><a data-url="http://yoursite.com/2015/05/23/2015-04-25-深入浅出理解接口回调/" data-id="cikpisp1l0000p4uy93h8quy3" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/接口回调/">接口回调</a></div><div class="post-nav"><a href="/2015/05/24/Adapter/" class="pre"><i class="fa fa-caret-left"> 打造万能的ListView适配器</i></a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/接口回调/" style="font-size: 15px;">接口回调</a> <a href="/tags/Json解析/" style="font-size: 15px;">Json解析</a> <a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a> <a href="/tags/adapter/" style="font-size: 15px;">adapter</a> <a href="/tags/Java并发/" style="font-size: 15px;">Java并发</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Activity/" style="font-size: 15px;">Activity</a> <a href="/tags/ListView适配器/" style="font-size: 15px;">ListView适配器</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/02/15/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/15/解析Map型的Json数据/">解析Map型的Json数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/23/Java基础/">Java基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/AndroidLaunchMode/">Activity的启动模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/07/RecyclerView/">RecyclerView适配器的省略写法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/07/06/Android中的一些小技巧/">Android中的一些小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/12/Java中的并发/">Java中并发</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/24/Adapter/">打造万能的ListView适配器</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/23/2015-04-25-深入浅出理解接口回调/">深入浅出理解接口回调</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">ijaysdevbg.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/share.js?v=0.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>